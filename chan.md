# Chanels

Как и карты, каналы выделяются make, а результирующее значение действует как ссылка на базовую структуру данных. 
Если указан необязательный целочисленный параметр, он устанавливает размер буфера для канала. 
По умолчанию это ноль для небуферизованного или синхронного канала.

```golang
ci: = make (chan int) // небуферизованный канал целых чисел
cj: = make (chan int, 0) // небуферизованный канал целых чисел
cs: = make (chan * os.File, 100) // буферизованный канал указателей на файлы

```
Небуферизованные каналы объединяют связь - обмен значениями - с синхронизацией, гарантируя, что два вычисления (процедуры) находятся в известном состоянии.
Есть много хороших идиом, использующих каналы. Вот один, чтобы начать нас. В предыдущем разделе мы запустили сортировку в фоновом режиме. Канал может позволить запускающей программе ожидать завершения сортировки.

```golang
c: = make (chan int) // Выделить канал.
// Запускаем сортировку в goroutine; когда это завершится, сигнал на канале.
go func () {
    list.sort ()
    c <- 1 // Отправить сигнал; значение не имеет значения.
} ()
doSomethingForAWhile ()
<-c // Дождаться окончания сортировки; отменить отправленное значение.
```

Приемники всегда блокируются, пока нет данных для приема. 
Если канал не буферизован, отправитель блокируется, пока получатель не получит значение. 
Если у канала есть буфер, отправитель блокируется только до тех пор, пока значение не будет скопировано в буфер; 
если буфер заполнен, это означает ожидание, пока какой-либо получатель не получит значение.

Буферизованный канал может использоваться как семафор, например, для ограничения пропускной способности. 
В этом примере входящие запросы передаются в handle, который отправляет значение в канал, обрабатывает запрос, 
а затем получает значение из канала, чтобы подготовить «семафор» для следующего потребителя. 
Емкость буфера канала ограничивает количество одновременных вызовов до process.

```golang
var sem = make (chan int, MaxOutstanding)

func handle (r * Request) {
    sem <- 1 // Ожидание истечения активной очереди.
    process (r) // Может занять много времени.
    <-sem // Готово; включить следующий запрос для запуска.
}

func Serve (очередь chan * Request) {
    за {
        req: = <-queue
        go handle (req) // Не ждите окончания обработки handle.
    }
}
```

Как только MaxOutstandingобработчики выполняются process, все больше будет блокировать попытки отправки 
в заполненный буфер канала, пока один из существующих обработчиков не завершит работу и не получит из буфера.

Однако у этого дизайна есть проблема: Serve создается новая процедура для каждого входящего запроса, 
даже если MaxOutstanding в любой момент может быть запущен только один из них. 
В результате программа может потреблять неограниченные ресурсы, если запросы поступают слишком быстро. 
Мы можем устранить этот недостаток, перейдя Serveк созданию горутин. 
Вот очевидное решение, но остерегайтесь, в нем есть ошибка, которую мы исправим позже:

```golang
func Serve (очередь chan * Request) {
    для req: = дальность очереди {
        сем <- 1
        go func () {
            process (req) // Buggy; см. объяснение ниже.
            <-sem
        } ()
    }
}
```

Ошибка заключается в том, что в forцикле Go переменная цикла используется повторно для каждой итерации, 
поэтому req переменная является общей для всех программ. Это не то, что мы хотим. 
Нам нужно убедиться, что reqэто уникально для каждой программы. 
Вот один из способов сделать это, передав значение reqв качестве аргумента замыканию в программе:

```golang
func Serve (очередь chan * Request) {
    для req: = дальность очереди {
        сем <- 1
        go func (req * Request) {
            Процесс (REQ)
            <-sem
        } (REQ)
    }
}
```

Сравните эту версию с предыдущей, чтобы увидеть разницу в том, как закрытие объявляется и выполняется. 
Другое решение - просто создать новую переменную с тем же именем, как в этом примере:

```golang
func Serve (очередь chan * Request) {
    для req: = дальность очереди {
        req: = req // Создать новый экземпляр req для программы.
        сем <- 1
        go func () {
            Процесс (REQ)
            <-sem
        } ()
    }
}
```

Это может показаться странным, чтобы написать

req: = req
но в Go это законно и идиоматично. Вы получаете новую версию переменной с тем же именем, 
намеренно скрывая переменную цикла локально, но уникально для каждой программы.

Возвращаясь к общей проблеме написания сервера, другой подход, который хорошо управляет ресурсами, 
состоит в том, чтобы начать фиксированное количество процедур, handleвсе считывающих из канала запроса. 
Количество программ ограничивает количество одновременных звонков process. 
Эта Serveфункция также принимает канал, по которому будет сказано выйти; 
после запуска goroutines он блокирует прием с этого канала.

```golang
дескриптор func (очередь chan * Request) {
    для r: = очередь диапазона {
        Процесс (г)
    }
}

func Serve (clientRequests chan * Request, выйти из chan bool) {
    // Запускать обработчики
    для i: = 0; я <MaxOutstanding; я ++ {
        go handle (clientRequests)
    }
    <-quit // Дождаться, чтобы получить сообщение о выходе.
}
```


## Каналы каналов
Одним из наиболее важных свойств Go является то, что канал - это первоклассное значение, 
которое можно распределять и передавать, как и любое другое. 
Обычно это свойство используется для реализации безопасного параллельного демультиплексирования.


В примере из предыдущего раздела handleбыл идеализированный обработчик запроса,
но мы не определили тип, который он обрабатывал. Если этот тип включает в себя канал для ответа, 
каждый клиент может предоставить свой собственный путь для ответа. 
Вот схематическое определение типа Request.

```golang
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
```

Клиент предоставляет функцию и ее аргументы, а также канал внутри объекта запроса, по которому следует получить ответ.

```golang
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests <- request
// Wait for response.
fmt.Printf("answer: %d\n", <-request.resultChan)
```
На стороне сервера функция обработчика - единственное, что изменяется.

```golang
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
```
Очевидно, что еще многое предстоит сделать, чтобы сделать его реалистичным, 
но этот код представляет собой основу для параллельной неблокирующей RPC-системы 
с ограниченной скоростью, и мьютекса в поле зрения нет.











