# Chanels

Как и карты, каналы выделяются make, а результирующее значение действует как ссылка на базовую структуру данных. 
Если указан необязательный целочисленный параметр, он устанавливает размер буфера для канала. 
По умолчанию это ноль для небуферизованного или синхронного канала.

```golang
ci: = make (chan int) // небуферизованный канал целых чисел
cj: = make (chan int, 0) // небуферизованный канал целых чисел
cs: = make (chan * os.File, 100) // буферизованный канал указателей на файлы

```
Небуферизованные каналы объединяют связь - обмен значениями - с синхронизацией, гарантируя, что два вычисления (процедуры) находятся в известном состоянии.
Есть много хороших идиом, использующих каналы. Вот один, чтобы начать нас. В предыдущем разделе мы запустили сортировку в фоновом режиме. Канал может позволить запускающей программе ожидать завершения сортировки.

```golang

c: = make (chan int) // Выделить канал.
// Запускаем сортировку в goroutine; когда это завершится, сигнал на канале.
go func () {
    list.sort ()
    c <- 1 // Отправить сигнал; значение не имеет значения.
} ()
doSomethingForAWhile ()
<-c // Дождаться окончания сортировки; отменить отправленное значение.
```

Приемники всегда блокируются, пока нет данных для приема. 
Если канал не буферизован, отправитель блокируется, пока получатель не получит значение. 
Если у канала есть буфер, отправитель блокируется только до тех пор, пока значение не будет скопировано в буфер; 
если буфер заполнен, это означает ожидание, пока какой-либо получатель не получит значение.

Буферизованный канал может использоваться как семафор, например, для ограничения пропускной способности. 
В этом примере входящие запросы передаются в handle, который отправляет значение в канал, обрабатывает запрос, 
а затем получает значение из канала, чтобы подготовить «семафор» для следующего потребителя. 
Емкость буфера канала ограничивает количество одновременных вызовов до process.

```golang
var sem = make (chan int, MaxOutstanding)

func handle (r * Request) {
    sem <- 1 // Ожидание истечения активной очереди.
    process (r) // Может занять много времени.
    <-sem // Готово; включить следующий запрос для запуска.
}

func Serve (очередь chan * Request) {
    за {
        req: = <-queue
        go handle (req) // Не ждите окончания обработки handle.
    }
}
```

Как только MaxOutstandingобработчики выполняются process, все больше будет блокировать попытки отправки 
в заполненный буфер канала, пока один из существующих обработчиков не завершит работу и не получит из буфера.

Однако у этого дизайна есть проблема: Serve создается новая процедура для каждого входящего запроса, 
даже если MaxOutstanding в любой момент может быть запущен только один из них. 
В результате программа может потреблять неограниченные ресурсы, если запросы поступают слишком быстро. 
Мы можем устранить этот недостаток, перейдя Serveк созданию горутин. 
Вот очевидное решение, но остерегайтесь, в нем есть ошибка, которую мы исправим позже:

```golang
func Serve (очередь chan * Request) {
    для req: = дальность очереди {
        сем <- 1
        go func () {
            process (req) // Buggy; см. объяснение ниже.
            <-sem
        } ()
    }
}
```

Ошибка заключается в том, что в forцикле Go переменная цикла используется повторно для каждой итерации, 
поэтому req переменная является общей для всех программ. Это не то, что мы хотим. 
Нам нужно убедиться, что reqэто уникально для каждой программы. 
Вот один из способов сделать это, передав значение reqв качестве аргумента замыканию в программе:

```golang
func Serve(queue chan *Request) {
    for req := range queue {
        sem <- 1
        go func() {
            process(req) // Buggy; see explanation below.
            <-sem
        }()
    }
}
```

Сравните эту версию с предыдущей, чтобы увидеть разницу в том, как закрытие объявляется и выполняется. 
Другое решение - просто создать новую переменную с тем же именем, как в этом примере:

```golang
func Serve (очередь chan * Request) {
    для req: = дальность очереди {
        req: = req // Создать новый экземпляр req для программы.
        сем <- 1
        go func () {
            Процесс (REQ)
            <-sem
        } ()
    }
}
```

Это может показаться странным, чтобы написать

req: = req
но в Go это законно и идиоматично. Вы получаете новую версию переменной с тем же именем, 
намеренно скрывая переменную цикла локально, но уникально для каждой программы.

Возвращаясь к общей проблеме написания сервера, другой подход, который хорошо управляет ресурсами, 
состоит в том, чтобы начать фиксированное количество процедур, handleвсе считывающих из канала запроса. 
Количество программ ограничивает количество одновременных звонков process. 
Эта Serveфункция также принимает канал, по которому будет сказано выйти; 
после запуска goroutines он блокирует прием с этого канала.

```golang
func Serve(queue chan *Request) {
    for req := range queue {
        sem <- 1
        go func(req *Request) {
            process(req)
            <-sem
        }(req)
    }
}
```
Сравните эту версию с предыдущей, чтобы увидеть разницу в том, как закрытие объявляется и выполняется. Другое решение - просто создать новую переменную с тем же именем, как в этом примере:

```golang
func Serve(queue chan *Request) {
    for req := range queue {
        req := req // Create new instance of req for the goroutine.
        sem <- 1
        go func() {
            process(req)
            <-sem
        }()
    }
}
```


## Каналы каналов
Одним из наиболее важных свойств Go является то, что канал - это первоклассное значение, 
которое можно распределять и передавать, как и любое другое. 
Обычно это свойство используется для реализации безопасного параллельного демультиплексирования.


В примере из предыдущего раздела handleбыл идеализированный обработчик запроса,
но мы не определили тип, который он обрабатывал. Если этот тип включает в себя канал для ответа, 
каждый клиент может предоставить свой собственный путь для ответа. 
Вот схематическое определение типа Request.

```golang
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
```

Клиент предоставляет функцию и ее аргументы, а также канал внутри объекта запроса, по которому следует получить ответ.

```golang
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests <- request
// Wait for response.
fmt.Printf("answer: %d\n", <-request.resultChan)
```
На стороне сервера функция обработчика - единственное, что изменяется.

```golang
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan <- req.f(req.args)
    }
}
```
Очевидно, что еще многое предстоит сделать, чтобы сделать его реалистичным, 
но этот код представляет собой основу для параллельной неблокирующей RPC-системы 
с ограниченной скоростью, и мьютекса в поле зрения нет.

## Распараллеливание
Другое применение этих идей - распараллелить вычисления на нескольких ядрах процессора. Если вычисление может быть разбито на отдельные части, которые могут выполняться независимо, оно может быть распараллелено, с каналом, чтобы сигнализировать, когда каждая часть завершается.

Допустим, у нас есть дорогостоящая операция для выполнения над вектором элементов, и что значение операции для каждого элемента является независимым, как в этом идеализированном примере.


```golang
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1    // signal that this piece is done
}
```

Мы запускаем фрагменты независимо друг от друга, по одному на каждый процессор. Они могут быть выполнены в любом порядке, но это не имеет значения; мы просто подсчитываем сигналы завершения, опустошая канал после запуска всех процедур.

```golang
const numCPU = 4 // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, numCPU)  // Buffering optional but sensible.
    for i := 0; i < numCPU; i++ {
        go v.DoSome(i*len(v)/numCPU, (i+1)*len(v)/numCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i < numCPU; i++ {
        <-c    // wait for one task to complete
    }
    // All done.
}
```
Вместо того, чтобы создавать постоянное значение для numCPU, мы можем спросить среду выполнения, какое значение подходит. Функция runtime.NumCPU возвращает количество аппаратных ядер процессора в машине, поэтому мы могли бы написать

```golang
var numCPU = runtime.NumCPU ()
```

Существует также функция runtime.GOMAXPROCS, которая сообщает (или устанавливает) заданное пользователем количество ядер, которое может запускать программа Go одновременно. По умолчанию это значение равно значению, runtime.NumCPUно его можно переопределить, задав одноименную переменную среды оболочки или вызвав функцию с положительным числом. Вызов его с нуля просто запрашивает значение. Поэтому, если мы хотим удовлетворить запрос ресурса пользователя, мы должны написать

```golang
var numCPU = runtime.GOMAXPROCS (0)
```

Не путайте идеи параллелизма - структурирования программы как независимо выполняемых компонентов - и параллелизма - параллельного выполнения вычислений для повышения эффективности на нескольких процессорах. Хотя функции параллелизма в Go могут упростить структурирование некоторых проблем в виде параллельных вычислений, Go - это параллельный, а не параллельный язык, и не все проблемы распараллеливания подходят для модели Go. Для обсуждения различия, см. Сообщение, цитируемое в этом сообщении в блоге .

# Негерметичный буфер

Инструменты параллельного программирования могут даже облегчить выражение несовпадающих идей. Вот пример, извлеченный из пакета RPC. Клиентская программа циклически принимает данные из какого-то источника, возможно, из сети. Чтобы избежать выделения и освобождения буферов, он хранит свободный список и использует буферизованный канал для его представления. Если канал пуст, выделяется новый буфер. Когда буфер сообщений готов, он отправляется на сервер serverChan.

```golang
var freeList = make (chan * Buffer, 100) 
var serverChan = make (chan * Buffer) 

func client () { 
    for { 
        var b * Buffer 
        // Захватить буфер, если он доступен; выделить, если нет. 
        select { 
        case b = <-freeList: 
            // Получил один; больше нечего делать. 
        default: 
            // Нет свободного, поэтому выделите новый. 
            b = new (Buffer) 
        } 
        load (b) // Читать следующее сообщение из сети. 
        serverChan <- b // Отправить на сервер. 
    } 
}
```

Цикл сервера получает каждое сообщение от клиента, обрабатывает его и возвращает буфер в свободный список.

```golang
func server () { 
    for { 
        b: = <-serverChan // Ожидание работы. 
        process (b) 
        // Повторно использовать буфер, если есть место. 
        select { 
        case freeList <- b: 
            // Буфер в свободном списке; больше нечего делать. 
        default: 
            // Свободный список заполнен, просто продолжайте. 
        } 
    } 
}
```

Клиент пытается получить буфер из freeList; если ни один не доступен, он выделяет новый. Послать серверу для freeListкладет bобратно в свободный список , если список не является полным, в этом случае буфер сбрасывается на пол , чтобы быть утилизирован сборщиком мусора. (Предложения defaultв select операторах выполняются, когда ни один другой случай не готов, что означает, что selectsникогда не блокируется.) Эта реализация строит список без утечек в контейнерах всего за несколько строк, полагаясь на буферизованный канал и сборщик мусора для ведения учета.



# Recover

Когда panicвызывается, в том числе неявно для ошибок времени выполнения, таких как индексация фрагмента за пределами границ или сбой утверждения типа, он немедленно останавливает выполнение текущей функции и начинает разматывать стек программы, выполняя любые отложенные функции по пути. Если это раскручивание достигает вершины стека горутина, программа умирает. Однако можно использовать встроенную функцию recoverдля восстановления контроля над программой и возобновления нормального выполнения.

Вызов recoverостанавливает раскручивание и возвращает переданный аргумент panic. Поскольку единственный код, который выполняется при разматывании, находится внутри отложенных функций, recover он полезен только внутри отложенных функций.

Одним из применений recoverявляется отключение отказавшей программы внутри сервера без уничтожения других выполняющихся процедур.

```golang
func server(workChan <-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
```

В этом примере, если do(work)паникует, результат будет записан в журнал, и программа будет выходить чисто, не мешая другим. Нет необходимости делать что-либо еще в отсроченном закрытии; призвание recoverполностью обрабатывает состояние.

Поскольку recoverвсегда возвращается, nilесли не вызывается напрямую из отложенной функции, отложенный код может вызывать подпрограммы библиотеки, которые сами используют panicи recoverбез сбоев. Например, отложенная функция safelyDoможет вызывать функцию регистрации перед вызовом recover, и этот код регистрации будет выполняться независимо от состояния паники.

При наличии нашего шаблона восстановления do функция (и все, что она вызывает) может чисто выйти из любой плохой ситуации, вызвав ее panic. Мы можем использовать эту идею для упрощения обработки ошибок в сложном программном обеспечении. Давайте посмотрим на идеализированную версию regexpпакета, которая сообщает об ошибках анализа, вызывая panicлокальный тип ошибки. Вот определение Error, errorметод и Compileфункция.


```golang
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
```


При панике doParseблок восстановления установит возвращаемое значение nilравным - отложенные функции могут изменять именованные возвращаемые значения. Затем в присваивании он проверяет, errчто проблема была ошибкой разбора, утверждая, что она имеет локальный тип Error. Если этого не произойдет, утверждение типа не будет выполнено, что приведет к ошибке времени выполнения, которая продолжит разматывание стека, как будто ничто не прервало его. Эта проверка означает, что если произойдет что-то неожиданное, например, индекс вне границ, код не будет выполнен, даже если мы используем panicи recoverобрабатывать ошибки синтаксического анализа.

С обработкой ошибок на месте, errorметод (потому что это метод, связанный с типом, это нормально, даже естественно, если он имеет то же имя, что и встроенный errorтип), позволяет легко сообщать об ошибках синтаксического анализа, не беспокоясь о размотке стека анализа рукой:

```
if pos == 0 { 
    re.error ("'*' недопустимо в начале выражения") 
}
```

Хотя этот шаблон полезен, его следует использовать только внутри пакета. Parseпревращает свои внутренние panicвызовы в errorценности; это не подвергает panics его клиенту. Это хорошее правило для подражания.

Кстати, эта идиома повторной паники изменяет значение паники, если происходит настоящая ошибка. Однако как исходные, так и новые сбои будут представлены в отчете о сбое, поэтому основная причина проблемы все равно будет видна. Таким образом, этого простого подхода повторной паники обычно достаточно - в конце концов, это сбой - но если вы хотите отобразить только исходное значение, вы можете написать немного больше кода для фильтрации непредвиденных проблем и повторной паники с исходной ошибкой. Это оставлено в качестве упражнения для читателя.


# Веб-сервер
Давайте закончим с полной программой Go, веб-сервером. Это на самом деле своего рода веб-сервер. Google предоставляет сервис, chart.apis.google.com который выполняет автоматическое форматирование данных в виде диаграмм и графиков. Тем не менее, интерактивно сложно использовать, потому что вам нужно поместить данные в URL как запрос. Здесь программа предоставляет более приятный интерфейс для одной формы данных: с помощью короткого фрагмента текста она обращается к серверу диаграмм для создания QR-кода, матрицы блоков, кодирующих текст. Это изображение можно захватить с помощью камеры вашего мобильного телефона и интерпретировать, например, как URL, сохраняя при этом ввод URL-адреса на крошечной клавиатуре телефона.

Вот полная программа. Объяснение следует.

```golang
package main

import (
    "flag"
    "html/template"
    "log"
    "net/http"
)

var addr = flag.String("addr", ":1718", "http service address") // Q=17, R=18

var templ = template.Must(template.New("qr").Parse(templateStr))

func main() {
    flag.Parse()
    http.Handle("/", http.HandlerFunc(QR))
    err := http.ListenAndServe(*addr, nil)
    if err != nil {
        log.Fatal("ListenAndServe:", err)
    }
}

func QR(w http.ResponseWriter, req *http.Request) {
    templ.Execute(w, req.FormValue("s"))
}

const templateStr = `
<html>
<head>
<title>QR Link Generator</title>
</head>
<body>
{{if .}}
<img src="http://chart.apis.google.com/chart?chs=300x300&cht=qr&choe=UTF-8&chl={{.}}" />
<br>
{{.}}
<br>
<br>
{{end}}
<form action="/" name=f method="GET"><input maxLength=1024 size=70
name=s value="" title="Text to QR Encode"><input type=submit
value="Show QR" name=qr>
</form>
</body>
</html>
`
```

Части до mainдолжны быть легко следовать. Один флаг устанавливает HTTP-порт по умолчанию для нашего сервера. Переменная шаблона templ- это место, где происходит веселье. Он создает шаблон HTML, который будет выполняться сервером для отображения страницы; подробнее об этом чуть позже.

mainФункция анализирует флаги и, используя механизм о котором мы говорили выше, связывает функцию QRк корневому пути для сервера. Затем http.ListenAndServeвызывается для запуска сервера; он блокируется во время работы сервера.

QRпросто получает запрос, который содержит данные формы, и выполняет шаблон для данных в названном значении формы s.

Пакет шаблонов html/templateмощный; эта программа только затрагивает его возможности. По сути, он переписывает фрагмент текста HTML на лету, заменяя элементы, полученные из элементов данных, передаваемых templ.Execute, в данном случае, значению формы. Внутри шаблона text ( templateStr) части, разделенные двойной скобкой, обозначают действия шаблона. Часть от {{if .}} to {{end}}выполняется только в том случае, если значение текущего элемента данных, называемого .(точка), не является пустым. То есть, когда строка пуста, этот фрагмент шаблона подавляется.

В двух отрывках {{.}}говорится, что данные, представленные шаблону, - строка запроса, - отображаются на веб-странице. Пакет шаблона HTML автоматически обеспечивает соответствующее экранирование, чтобы текст можно было безопасно отображать.

Остальная часть строки шаблона - это просто HTML-код, отображаемый при загрузке страницы. Если это слишком быстрое объяснение, см. Документацию для пакета шаблонов для более тщательного обсуждения.

И вот что у вас есть: полезный веб-сервер в несколько строк кода плюс некоторый HTML-текст, управляемый данными. Go достаточно мощный, чтобы многое произошло в несколько строк.



















